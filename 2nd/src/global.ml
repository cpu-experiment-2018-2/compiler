(* let global_array' = *)
(*   [ *)
(*    ("n_objects", 1) *)
(*   ; ("objects", 60) *)
(*   ; ("screen", 3) *)
(*   ; ("viewpoint", 3) *)
(*   ; ("light", 3) *)
(*   ; ("beam", 1) *)
(*   ; ("dummy", 1) *)
(*   ; ("and_net", 50) *)
(*   ; ("dummy2", 1) *)
(*   ; ("or_net", 1) *)
(*   ; ("solver_dist", 1) *)
(*   ; ("intsec_rectside", 1) *)
(*   ; ("tmin", 1) *)
(*   ; ("intersection_point", 3) *)
(*   ; ("intersected_object_id", 1) *)
(*   ; ("nvector", 3) *)
(*   ; ("texture_color", 3) *)
(*   ; ("diffuse_ray", 3) *)
(*   ; ("rgb", 3) *)
(*   ; ("image_size", 2) *)
(*   ; ("image_center", 2) *)
(*   ; ("scan_pitch", 1) *)
(*   ; ("startp", 3) *)
(*   ; ("startp_fast", 3) *)
(*   ; ("screenx_dir", 3) *)
(*   ; ("screeny_dir", 3) *)
(*   ; ("screenz_dir", 3) *)
(*   ; ("ptrace_dirvec ", 3) *)
(*   ; ("dirvecs", 5) *)
(*   ; ("v3", 3) *)
(*   ; ("consts", 60) *)
(*   ; ("reflections", 180) *)
(*   ; ("n_reflections", 1)  *)
(*   ] *)
(*  *)
(* let global_tuple' = [("light_dirvec", ["v3";"consts"])] *)
(*  *)
(* type arr =  *)
(*     { name : string; pos : int ; ty : Type.t; length: int } *)
(* type tup =  *)
(*     { name : string; pos : int ; ty : Type.t; init : string list} *)
(*  *)
(* let rec gen_global offset =  *)
(*     List.fold_left (fun (name,len) (acc,hp) ->  *)
(*         (M.add name ({name = name;pos = hp; ty = Type.genvar() ; length = len}) , hp + len)) global_array' (M.empty , offset) *)
